using Microsoft.EntityFrameworkCore;
using OCC.API.Data;
using OCC.Shared.Models;
using System.Text.Json;

namespace OCC.API.Services
{
    public class AutoClockInService : BackgroundService
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<AutoClockInService> _logger;
        private readonly TimeSpan _checkInterval = TimeSpan.FromMinutes(15);

        public AutoClockInService(IServiceProvider serviceProvider, ILogger<AutoClockInService> logger)
        {
            _serviceProvider = serviceProvider;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("AutoClockInService is starting.");

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    await ProcessClockInAsync(stoppingToken);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "An error occurred while processing automatic clock-ins.");
                }

                await Task.Delay(_checkInterval, stoppingToken);
            }

            _logger.LogInformation("AutoClockInService is stopping.");
        }

        private async Task ProcessClockInAsync(CancellationToken stoppingToken)
        {
            using var scope = _serviceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();

            // 1. Check if feature is globally enabled
            var setting = await dbContext.AppSettings.FirstOrDefaultAsync(s => s.Key == "CompanyProfile", stoppingToken);
            if (setting == null || string.IsNullOrEmpty(setting.Value))
            {
                return;
            }

            var companyDetails = JsonSerializer.Deserialize<CompanyDetails>(setting.Value);
            if (companyDetails == null || !companyDetails.AutoClockInEnabled)
            {
                return; // Feature is disabled
            }

            var todayUtc = DateTime.UtcNow.DayOfWeek;
            bool isTodayEnabled = todayUtc switch
            {
                DayOfWeek.Monday => companyDetails.AutoClockInMonday,
                DayOfWeek.Tuesday => companyDetails.AutoClockInTuesday,
                DayOfWeek.Wednesday => companyDetails.AutoClockInWednesday,
                DayOfWeek.Thursday => companyDetails.AutoClockInThursday,
                DayOfWeek.Friday => companyDetails.AutoClockInFriday,
                DayOfWeek.Saturday => companyDetails.AutoClockInSaturday,
                DayOfWeek.Sunday => companyDetails.AutoClockInSunday,
                _ => false
            };

            if (!isTodayEnabled)
            {
                return; // Feature is not enabled for today
            }

            // 2. Get active employees
            var activeEmployees = await dbContext.Employees
                .Where(e => e.Status == EmployeeStatus.Active)
                .ToListAsync(stoppingToken);

            var today = DateTime.UtcNow.Date; // Handle local timezone properly depending on server, but UtcNow.Date is standard
            var currentTime = DateTime.Now.TimeOfDay; // Server local time for shift comparison

            int processedCount = 0;

            foreach (var employee in activeEmployees)
            {
                var shiftStartTime = employee.ShiftStartTime;
                var shiftEndTime = employee.ShiftEndTime;
                
                // Check if they already have an attendance record for today
                var existingRecord = await dbContext.AttendanceRecords
                    .FirstOrDefaultAsync(r => r.EmployeeId == employee.Id && r.Date.Date == today, stoppingToken);

                if (existingRecord == null)
                {
                    // If they don't have a record today, check if we should auto clock-in
                    // This naturally respects manual early clock-ins because if they manually clocked in at 06:45,
                    // an AttendanceRecord for today ALREADY EXISTS, so this entire block is skipped!
                    if (shiftStartTime != null && currentTime >= shiftStartTime.Value)
                    {
                        var record = new AttendanceRecord
                        {
                            Id = Guid.NewGuid(),
                            EmployeeId = employee.Id,
                            Date = today,
                            Branch = employee.Branch,
                            CheckInTime = today.Add(shiftStartTime.Value),
                            Status = AttendanceStatus.Present,
                            IsAutoClockIn = true,
                            Notes = "Auto Clock-In generated by system."
                        };

                        dbContext.AttendanceRecords.Add(record);
                        processedCount++;
                    }
                }
                else
                {
                    // If they have an open record today, check if we should auto clock-out
                    // IMPORTANT: Only auto clock out if they haven't manually clocked out yet!
                    // If CheckOutTime != null, they already left (e.g., early leaving), so do NOT overwrite it.
                    if (existingRecord.CheckOutTime == null && shiftEndTime != null && currentTime >= shiftEndTime.Value)
                    {
                        existingRecord.CheckOutTime = today.Add(shiftEndTime.Value);
                        
                        // We do not change IsAutoClockIn to true here if they manually clocked in this morning.
                        // We just append to the notes to clarify the system did the clock-out part.
                        if (string.IsNullOrEmpty(existingRecord.Notes))
                            existingRecord.Notes = "Auto Clock-Out generated by system.";
                        else
                            existingRecord.Notes += " | Auto Clock-Out generated by system.";
                            
                        processedCount++;
                    }
                }
            }

            if (processedCount > 0)
            {
                await dbContext.SaveChangesAsync(stoppingToken);
                _logger.LogInformation($"AutoClockInService: Automatically processed {processedCount} clock-in/out events.");
            }
        }
    }
}
