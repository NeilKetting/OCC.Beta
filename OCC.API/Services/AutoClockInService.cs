using Microsoft.EntityFrameworkCore;
using OCC.API.Data;
using OCC.Shared.Models;
using System.Text.Json;

namespace OCC.API.Services
{
    public class AutoClockInService : BackgroundService
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<AutoClockInService> _logger;
        private readonly TimeSpan _checkInterval = TimeSpan.FromMinutes(15);

        public AutoClockInService(IServiceProvider serviceProvider, ILogger<AutoClockInService> logger)
        {
            _serviceProvider = serviceProvider;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("AutoClockInService is starting.");

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    await ProcessClockInAsync(stoppingToken);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "An error occurred while processing automatic clock-ins.");
                }

                await Task.Delay(_checkInterval, stoppingToken);
            }

            _logger.LogInformation("AutoClockInService is stopping.");
        }

        private async Task ProcessClockInAsync(CancellationToken stoppingToken)
        {
            using var scope = _serviceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();

            // 1. Check if feature is globally enabled
            var setting = await dbContext.AppSettings.FirstOrDefaultAsync(s => s.Key == "CompanyProfile", stoppingToken);
            if (setting == null || string.IsNullOrEmpty(setting.Value))
            {
                return;
            }

            var companyDetails = JsonSerializer.Deserialize<CompanyDetails>(setting.Value);
            if (companyDetails == null || !companyDetails.AutoClockInEnabled)
            {
                return; // Feature is disabled
            }

            // 2. Get active employees
            var activeEmployees = await dbContext.Employees
                .Where(e => e.Status == EmployeeStatus.Active)
                .ToListAsync(stoppingToken);

            var today = DateTime.UtcNow.Date; // Handle local timezone properly depending on server, but UtcNow.Date is standard
            var currentTime = DateTime.Now.TimeOfDay; // Server local time for shift comparison

            int processedCount = 0;

            foreach (var employee in activeEmployees)
            {
                var shiftStartTime = employee.ShiftStartTime;
                var shiftEndTime = employee.ShiftEndTime;
                
                // Check if they already have an attendance record for today
                var existingRecord = await dbContext.AttendanceRecords
                    .FirstOrDefaultAsync(r => r.EmployeeId == employee.Id && r.Date.Date == today, stoppingToken);

                if (existingRecord == null)
                {
                    // If they don't have a record today, check if we should auto clock-in
                    if (shiftStartTime != null && currentTime >= shiftStartTime.Value)
                    {
                        var record = new AttendanceRecord
                        {
                            Id = Guid.NewGuid(),
                            EmployeeId = employee.Id,
                            Date = today,
                            CheckInTime = today.Add(shiftStartTime.Value),
                            Status = AttendanceStatus.Present,
                            IsAutoClockIn = true,
                            Notes = "Auto Clock-In generated by system."
                        };

                        dbContext.AttendanceRecords.Add(record);
                        processedCount++;
                    }
                }
                else
                {
                    // If they have an open record today, check if we should auto clock-out
                    if (existingRecord.CheckOutTime == null && shiftEndTime != null && currentTime >= shiftEndTime.Value)
                    {
                        existingRecord.CheckOutTime = today.Add(shiftEndTime.Value);
                        
                        if (string.IsNullOrEmpty(existingRecord.Notes))
                            existingRecord.Notes = "Auto Clock-Out generated by system.";
                        else
                            existingRecord.Notes += " | Auto Clock-Out generated by system.";
                            
                        processedCount++;
                    }
                }
            }

            if (processedCount > 0)
            {
                await dbContext.SaveChangesAsync(stoppingToken);
                _logger.LogInformation($"AutoClockInService: Automatically processed {processedCount} clock-in/out events.");
            }
        }
    }
}
